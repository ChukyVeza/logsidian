---
permalink: "notes/{{ page.fileSlug | slugify }}/"
---
<!DOCTYPE html>
<html lang="{{ meta.mainLanguage }}">
  <head>
    <title>{% if title %}{{ title }}{% else %}{{ page.fileSlug }}{% endif %}</title>
    {%include "components/pageheader.njk"%}
    {% for imp in dynamics.common.head %}
      {% include imp %}
    {% endfor %}
    {% for imp in dynamics.notes.head %}
      {% include imp %}
    {% endfor %}
    
    <!-- âœ… CSS MEJORADO - ESTRUCTURA ANIDADA CORRECTA -->
<style>
/* ===== CHECKBOXES MEJORADOS ===== */
input[type="checkbox"] {
  margin-right: 12px !important;
  transform: scale(1.5) !important;
  vertical-align: middle !important;
  cursor: pointer !important;
}

.custom-checkbox-js {
  margin-right: 12px !important;
  transform: scale(1.5) !important;
  vertical-align: middle !important;
  cursor: pointer !important;
}

/* ===== ESTRUCTURA DE LISTAS MEJORADA ===== */
/* Listas principales */
.cm-s-obsidian ul, 
.cm-s-obsidian ol {
  margin-left: 0 !important;
  padding-left: 1.5rem !important;
  list-style-position: outside !important;
}

/* Niveles de anidaciÃ³n progresiva */
.cm-s-obsidian ul ul, 
.cm-s-obsidian ol ul, 
.cm-s-obsidian ul ol, 
.cm-s-obsidian ol ol {
  margin-left: 0 !important;
  padding-left: 2rem !important;
  border-left: 2px solid #4b5563 !important;
  margin-top: 0.25em !important;
  margin-bottom: 0.25em !important;
}

.cm-s-obsidian ul ul ul, 
.cm-s-obsidian ol ul ul, 
.cm-s-obsidian ul ol ul, 
.cm-s-obsidian ol ol ul {
  margin-left: 0 !important;
  padding-left: 2rem !important;
  border-left: 1px solid #6b7280 !important;
}

/* Items de lista */
.cm-s-obsidian li {
  margin: 0.4em 0 !important;
  line-height: 1.5 !important;
  position: relative !important;
}

/* Checkboxes mejorados */
.cm-s-obsidian input[type="checkbox"] {
  margin-right: 8px !important;
  transform: scale(1.2) !important;
  vertical-align: middle !important;
}

/* Estilos especÃ­ficos para listas de tareas */
.cm-s-obsidian ul.contains-task-list {
  padding-left: 0.5rem !important;
}

.cm-s-obsidian li.task-list-item {
  padding-left: 0.5rem !important;
  list-style: none !important;
}

/* IndentaciÃ³n visual para diferentes niveles */
.cm-s-obsidian li.task-list-item > ul.contains-task-list {
  margin-left: 1rem !important;
  padding-left: 1.5rem !important;
  border-left: 2px solid #374151 !important;
}

/* Listas convertidas */
.converted-task-list {
  list-style: none !important;
  padding-left: 1.5rem !important;
  margin: 1em 0 !important;
}

.converted-task-item {
  margin: 0.5em 0 !important;
  padding-left: 0 !important;
  position: relative !important;
}

/* Contenedor para listas anidadas */
.nested-list-container {
  width: 100% !important;
}

/* Mejoras visuales para mejor legibilidad */
.converted-task-list {
  background: transparent !important;
  border-radius: 4px !important;
}

.converted-task-item {
  transition: background-color 0.2s ease !important;
}

.converted-task-item:hover {
  background-color: rgba(255, 255, 255, 0.02) !important;
}

/* Estilos para elementos de texto dentro de listas */
.converted-task-item em {
  color: #9ca3af !important;
  font-style: italic !important;
}

.converted-task-item strong {
  color: #f3f4f6 !important;
  font-weight: 600 !important;
}

/* Mejora para enlaces internos */
.internal-link {
  color: #60a5fa !important;
  text-decoration: none !important;
}

.internal-link:hover {
  text-decoration: underline !important;
}

/* Tags mejorados */
.tag {
  background: #374151 !important;
  color: #d1d5db !important;
  padding: 2px 8px !important;
  border-radius: 12px !important;
  font-size: 0.75rem !important;
  margin-right: 4px !important;
}
</style>
  </head>
  <body class="theme-{{meta.baseTheme}} markdown-preview-view markdown-rendered markdown-preview-section {{meta.bodyClasses}}">
    {%include "components/notegrowthhistory.njk"%}
    
    {% if settings.dgShowFileTree !== true %}
      {%include "components/navbar.njk"%}
    {%else%}
      {%include "components/filetree.njk"%}
    {% endif %}

    {% if settings.dgEnableSearch === true %}
      {%include "components/searchContainer.njk"%}
    {% endif %}

    <main class="content cm-s-obsidian {{contentClasses}}">
      <header>
        {% if settings.dgShowInlineTitle === true %}
          <h1 data-note-icon="{% if noteIcon %}{{noteIcon}}{% else %}{{meta.noteIconsSettings.default}}{% endif %}">{% if title %}{{ title }}{% else %}{{ page.fileSlug }}{% endif %}</h1>
        {% endif %}
        <div class="header-meta">
          {% if settings.dgShowTags === true and tags %}
            <div class="header-tags">
              {% for tag in tags %}
                {% if tag != 'gardenEntry' and tag !='note' %}
                  <a class="tag" onclick="toggleTagSearch(this)">
                    #{{tag}}
                  </a>
                {% endif %}
              {% endfor %}
            </div>
          {% endif %}
          {%- if meta.timestampSettings.showCreated or meta.timestampSettings.showUpdated -%}
          <div class="timestamps">
            {%- if meta.timestampSettings.showCreated and created -%}
            <div><i icon-name="calendar-plus"></i> <span class="human-date" data-date="{{created}}"></span></div>
            {%- endif -%}
            {%- if meta.timestampSettings.showUpdated and updated -%}
            <div><i icon-name="calendar-clock"></i> <span class="human-date" data-date="{{updated}}"></span></div>
            {%- endif -%}
          </div>
          {%- endif -%}
        </div>
      {% for imp in dynamics.common.header %}
        {% include imp %}
      {% endfor %}
      {% for imp in dynamics.notes.header %}
        {% include imp %}
      {% endfor %}
      </header>
      {% for imp in dynamics.common.beforeContent %}
        {% include imp %}
      {% endfor %}
      {% for imp in dynamics.notes.beforeContent %}
        {% include imp %}
      {% endfor %}
      {{ content | hideDataview | taggify | link | safe}}
      {% for imp in dynamics.common.afterContent %}
        {% include imp %}
      {% endfor %}
      {% for imp in dynamics.notes.afterContent %}
        {% include imp %}
      {% endfor %}
    </main>

    {% if settings.dgShowBacklinks === true or settings.dgShowLocalGraph === true or settings.dgShowToc === true%}
      {%include "components/sidebar.njk"%}
    {% endif %}

    {% if settings.dgLinkPreview === true %}
      {%include "components/linkPreview.njk"%}
    {% endif %}
    {% include "components/references.njk" %}
    {% include "components/timestamps.njk" %}
    {% for imp in dynamics.common.footer %}
      {% include imp %}
    {% endfor %}
    {% for imp in dynamics.notes.footer %}
      {% include imp %}
    {% endfor %}
    {%include "components/lucideIcons.njk"%}
    
    <!-- âœ… SCRIPT COMPLETAMENTE MEJORADO - ESTRUCTURA ANIDADA CORRECTA -->
    <script>
    // ðŸš¨ CONVERSIÃ“N MEJORADA CON ANIDACIÃ“N INTELIGENTE ðŸš¨
    function convertAllCheckboxes() {
      console.log('ðŸ”„ Buscando checkboxes para convertir...');
      
      const allElements = document.querySelectorAll('*');
      let convertedCount = 0;
      
      allElements.forEach(element => {
        if (element.tagName !== 'INPUT' && (element.innerHTML.includes('[ ]') || element.innerHTML.includes('[x]'))) {
          
          if (element.innerHTML.includes('[ ]')) {
            element.innerHTML = element.innerHTML.replace(/\[ \]/g, '<input type="checkbox" class="custom-checkbox-js">');
            convertedCount++;
          }
          
          if (element.innerHTML.includes('[x]')) {
            element.innerHTML = element.innerHTML.replace(/\[x\]/g, '<input type="checkbox" class="custom-checkbox-js" checked>');
            convertedCount++;
          }
        }
      });
      
      console.log(`âœ… Convertidos ${convertedCount} checkboxes`);
    }

    // ðŸš¨ CONVERSIÃ“N DE PÃRRAFOS A ESTRUCTURA DE LISTAS ANIDADAS ðŸš¨
    function convertParagraphsToNestedLists() {
      console.log('ðŸ”„ Convirtiendo pÃ¡rrafos a estructura anidada...');
      
      const paragraphs = document.querySelectorAll('p');
      let convertedCount = 0;
      
      paragraphs.forEach(paragraph => {
        const content = paragraph.innerHTML;
        
        if ((content.includes('- [ ]') || content.includes('- [x]')) && content.includes('<br>')) {
          const lines = content.split('<br>');
          const listStack = [];
          let rootList = null;
          let currentList = null;
          let lastIndentLevel = 0;
          
          lines.forEach((line, index) => {
            if (line.trim()) {
              // Calcular nivel de indentaciÃ³n
              const indentSpaces = (line.match(/^(\s*)/) || [''])[0].length;
              const indentLevel = Math.floor(indentSpaces / 2);
              
              // Crear elemento de lista
              const listItem = document.createElement('li');
              listItem.className = 'converted-task-item';
              
              // Procesar contenido de la lÃ­nea
              let cleanLine = line.trim();
              cleanLine = cleanLine.replace(/\[ \]/g, '<input type="checkbox" class="custom-checkbox-js">');
              cleanLine = cleanLine.replace(/\[x\]/g, '<input type="checkbox" class="custom-checkbox-js" checked>');
              cleanLine = cleanLine.replace(/^-\s+/, '');
              
              listItem.innerHTML = cleanLine;
              
              // Manejar cambios de nivel
              if (indentLevel > lastIndentLevel) {
                // Crear nueva lista anidada
                const nestedList = document.createElement('ul');
                nestedList.className = 'converted-task-list';
                
                if (currentList && currentList.lastElementChild) {
                  currentList.lastElementChild.appendChild(nestedList);
                  listStack.push(currentList);
                  currentList = nestedList;
                }
              } else if (indentLevel < lastIndentLevel) {
                // Regresar niveles
                const levelsToPop = lastIndentLevel - indentLevel;
                for (let i = 0; i < levelsToPop && listStack.length > 0; i++) {
                  currentList = listStack.pop();
                }
              }
              
              // Inicializar lista raÃ­z si es necesario
              if (!rootList) {
                rootList = document.createElement('ul');
                rootList.className = 'converted-task-list';
                currentList = rootList;
              }
              
              // Agregar item a la lista actual
              if (currentList) {
                currentList.appendChild(listItem);
              }
              
              lastIndentLevel = indentLevel;
            }
          });
          
          // Reemplazar pÃ¡rrafo con la estructura creada
          if (rootList) {
            const container = document.createElement('div');
            container.className = 'nested-list-container';
            container.appendChild(rootList);
            paragraph.parentNode.replaceChild(container, paragraph);
            convertedCount++;
          }
        }
      });
      
      console.log(`âœ… Convertidos ${convertedCount} pÃ¡rrafos a listas anidadas`);
    }

    // ðŸš¨ CONVERSIÃ“N DE ESTRUCTURA PLANA EXISTENTE ðŸš¨
    function convertFlatListsToNested() {
      console.log('ðŸ”„ Mejorando listas planas existentes...');
      
      // Buscar pÃ¡rrafos que contengan mÃºltiples items de lista
      const paragraphs = document.querySelectorAll('p');
      paragraphs.forEach(paragraph => {
        const htmlContent = paragraph.innerHTML;
        
        if ((htmlContent.includes('- [ ]') || htmlContent.includes('- [x]')) && 
            htmlContent.split('<br>').length > 1) {
          
          const lines = htmlContent.split('<br>');
          const list = document.createElement('ul');
          list.className = 'converted-task-list';
          
          lines.forEach(line => {
            if (line.trim()) {
              const listItem = document.createElement('li');
              listItem.className = 'converted-task-item';
              
              let processedLine = line.trim();
              processedLine = processedLine.replace(/\[ \]/g, '<input type="checkbox" class="custom-checkbox-js">');
              processedLine = processedLine.replace(/\[x\]/g, '<input type="checkbox" class="custom-checkbox-js" checked>');
              processedLine = processedLine.replace(/^-\s+/, '');
              
              listItem.innerHTML = processedLine;
              list.appendChild(listItem);
            }
          });
          
          paragraph.parentNode.replaceChild(list, paragraph);
        }
      });
    }

    // ðŸš¨ MEJORA DE ESTRUCTURAS EXISTENTES ðŸš¨
    function enhanceExistingStructures() {
      console.log('ðŸ”„ Mejorando estructuras existentes...');
      
      // Aplicar clases a listas existentes
      const existingLists = document.querySelectorAll('ul, ol');
      existingLists.forEach(list => {
        if (!list.classList.contains('converted-task-list')) {
          list.classList.add('converted-task-list');
        }
        
        // Aplicar clases a items existentes
        const listItems = list.querySelectorAll('li');
        listItems.forEach(item => {
          if (!item.classList.contains('converted-task-item')) {
            item.classList.add('converted-task-item');
          }
        });
      });
    }

    // ðŸš¨ FUNCIÃ“N PRINCIPAL MEJORADA ðŸš¨
    function convertAllElements() {
      console.log('=== INICIANDO CONVERSIÃ“N COMPLETA ===');
      convertFlatListsToNested();
      convertParagraphsToNestedLists();
      convertAllCheckboxes();
      enhanceExistingStructures();
      console.log('=== CONVERSIÃ“N COMPLETADA ===');
    }

    // ðŸš¨ INICIALIZACIÃ“N ROBUSTA ðŸš¨
    function initializeConversion() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', convertAllElements);
      } else {
        convertAllElements();
      }
      
      // MÃºltiples intentos para contenido dinÃ¡mico
      const delays = [50, 100, 300, 500, 1000, 2000];
      delays.forEach(delay => {
        setTimeout(convertAllElements, delay);
      });
    }

    // ðŸš¨ OBSERVADOR DE CAMBIOS EN EL DOM ðŸš¨
    function setupMutationObserver() {
      const observer = new MutationObserver(function(mutations) {
        let shouldConvert = false;
        
        mutations.forEach(mutation => {
          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            shouldConvert = true;
          } else if (mutation.type === 'characterData') {
            shouldConvert = true;
          }
        });
        
        if (shouldConvert) {
          setTimeout(convertAllElements, 100);
        }
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }

    // ðŸš¨ EJECUCIÃ“N PRINCIPAL ðŸš¨
    initializeConversion();
    setupMutationObserver();

    // Exportar funciones para debugging
    window.convertAllElements = convertAllElements;
    console.log('âœ… Script de conversiÃ³n cargado correctamente');
    </script>
  </body>
</html>